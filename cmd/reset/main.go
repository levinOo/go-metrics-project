package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type structInfo struct {
	Name   string
	Fields []fieldInfo
}
type fieldInfo struct {
	Name string
	Type string
}
type packageData struct {
	Package string
	Structs []structInfo
}

const templateStr = `// Code generated by go generate; DO NOT EDIT.

package {{.Package}}

{{range .Structs}}
func (s *{{.Name}}) Reset() {
{{range .Fields}}    s.{{.Name}} = {{.Type}}
{{end}}
}
{{end}}
`

var tmpl = template.Must(template.New("reset").Parse(templateStr))

// Основная точка входа
func main() {
	root, err := findModuleRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: %v\n", "Error finding module roo", err)
		os.Exit(1)
	}

	packages := map[string]*packageData{}
	err = filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil || !shouldParseFile(path, d) {
			return err
		}
		f, err := parseGoFile(path)
		if err != nil {
			return nil
		}
		structs := findStructsWithComment(f)
		if len(structs) == 0 {
			return nil
		}
		pkgDir := filepath.Dir(path)
		if packages[pkgDir] == nil {
			packages[pkgDir] = &packageData{Package: f.Name.Name}
		}
		packages[pkgDir].Structs = append(packages[pkgDir].Structs, structs...)
		return nil
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: %v\n", "Error walking directory", err)
		os.Exit(1)
	}

	for dir, pkg := range packages {
		if len(pkg.Structs) == 0 {
			continue
		}
		gen(dir, pkg)
	}
}

// Вспомогательные функции
func shouldParseFile(path string, d os.DirEntry) bool {
	return !d.IsDir() &&
		strings.HasSuffix(path, ".go") &&
		!strings.HasSuffix(path, "_test.go") &&
		!strings.HasSuffix(path, ".gen.go") &&
		!strings.Contains(path, "/vendor/") &&
		!strings.Contains(path, "/.git/")
}

func parseGoFile(path string) (*ast.File, error) {
	fset := token.NewFileSet()
	return parser.ParseFile(fset, path, nil, parser.ParseComments)
}

func gen(dir string, pkg *packageData) {
	var buf bytes.Buffer
	err := tmpl.Execute(&buf, pkg)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template for %s: %v\n", dir, err)
		return
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting code for %s: %v\n", dir, err)
		return
	}
	outPath := filepath.Join(dir, "reset.gen.go")
	err = os.WriteFile(outPath, formatted, 0644)
	if err == nil {
		fmt.Printf("Generated: %s\n", outPath)
	}
}

// Поиск структур с // generate:reset
func findStructsWithComment(file *ast.File) []structInfo {
	var result []structInfo
	ast.Inspect(file, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			return true
		}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			structType, ok2 := typeSpec.Type.(*ast.StructType)
			if !ok || !ok2 {
				continue
			}
			if hasGenerateResetComment(genDecl.Doc) || hasGenerateResetComment(typeSpec.Doc) {
				result = append(result, structInfo{
					Name:   typeSpec.Name.Name,
					Fields: extractFields(structType),
				})
			}
		}
		return true
	})
	return result
}
func hasGenerateResetComment(commentGroup *ast.CommentGroup) bool {
	if commentGroup != nil {
		for _, c := range commentGroup.List {
			if strings.TrimSpace(strings.TrimPrefix(c.Text, "//")) == "generate:reset" {
				return true
			}
		}
	}
	return false
}

// Извлечение zero value для типа
func extractFields(structType *ast.StructType) []fieldInfo {
	var fields []fieldInfo
	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			fields = append(fields, fieldInfo{
				Name: name.Name,
				Type: zeroValue(field.Type),
			})
		}
	}
	return fields
}
func zeroValue(expr ast.Expr) string {
	// Мапа для часто используемых базовых типов
	base := map[string]string{
		"int": "0", "int8": "0", "int16": "0", "int32": "0", "int64": "0",
		"uint": "0", "uint8": "0", "uint16": "0", "uint32": "0", "uint64": "0",
		"float32": "0", "float64": "0", "complex64": "0", "complex128": "0",
		"string": `""`, "bool": "false",
	}
	switch t := expr.(type) {
	case *ast.Ident:
		if v, found := base[t.Name]; found {
			return v
		}
		if t.Name == "time.Duration" {
			return "0"
		}
		if t.Name == "Storage" { // storage как отдельный тип
			return "nil"
		}
		return t.Name + "{}"
	case *ast.SelectorExpr:
		typ := typeFullName(t)
		if typ == "repository.Storage" {
			return "nil"
		}
		if typ == "time.Duration" {
			return "0"
		}
		return typ + "{}"
	case *ast.StarExpr, *ast.ArrayType, *ast.MapType, *ast.InterfaceType, *ast.ChanType:
		return "nil"
	default:
		return "nil"
	}
}
func typeFullName(sel *ast.SelectorExpr) string {
	// Получить pkg.Type по выражению
	var pkg string
	switch x := sel.X.(type) {
	case *ast.Ident:
		pkg = x.Name
	}
	return pkg + "." + sel.Sel.Name
}

// Поиск корня с go.mod
func findModuleRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found in parent tree")
		}
		dir = parent
	}
}
